@page "/gpu"
@using LP.Plot.Core.Data;
@using LP.Plot.Core.Skia;
@using SkiaSharp
@using SkiaSharp.Views.Blazor
@using LP.Plot.Core;

@inject DataService dataService;

<style>
    .canvas-container {
        line-height: 1;
    }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
        }
</style>

<h1>GPU (WebGL) Canvas</h1>

<p>The canvas below is using WebGL. See the great FPS!</p>

<div @ref="containerDiv" class="container" style="border: red 2px solid">
    <div class="row">
        <div class="col border rounded p-2 canvas-container">

            <SKGLView @ref="skiaEl" OnPaintSurface="OnPaintSurface" IgnorePixelScaling="true" EnableRenderLoop="false"
            @onmousedown="OnMouseDown"
            @onmousemove="OnMouseMove"
            @onmouseup="OnMouseUp"
            @onmousewheel="OnMouseWheel" />

        </div>
    </div>
</div>

@code {
    SKGLView skiaEl = null!;
    ElementReference containerDiv;
    Plot plot = null!;
    RenderInfo renderInfo = new();

    protected override async void OnInitialized()
    {
        base.OnInitialized();
        var data = await dataService.LoadSignal_L();
        plot = Plot.CreateSignal(data);
    }

    private void OnPaintSurface(SKPaintGLSurfaceEventArgs e)
    {
        var size = e.Info.Size;
        var canvas = e.Surface.Canvas;
        this.plot.Render(new SkiaRenderContext(canvas, size.Width, size.Height));
        renderInfo.PaintRenderInfo(canvas);
    }

    private bool isPanning = false;
    private (double X, double Y) lastMousePos = new();
    private void OnMouseDown(MouseEventArgs e)
    {
        isPanning = true;
        renderInfo.RestartMeasuring();
        lastMousePos = (X: e.ClientX, Y: e.ClientY);
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (!isPanning) return;
        var newMousePos = (X: e.ClientX, Y: e.ClientY);
        double deltaX = newMousePos.X - lastMousePos.X;
        double deltaY = newMousePos.Y - lastMousePos.Y;
        var clientRect = await containerDiv.MudGetBoundingClientRectAsync();
        var panx = -deltaX / clientRect.AbsoluteRight;
        var pany = deltaY / clientRect.AbsoluteBottom;
        plot.Pan(panx, pany);
        lastMousePos = newMousePos;
        skiaEl.Invalidate();
    }
    private void OnMouseUp(MouseEventArgs e)
    {
        isPanning = false;
    }

    private async Task OnMouseWheel(WheelEventArgs e)
    {
        var factor = Math.Sign(e.DeltaY) < 0 ? 0.9 : 1.1;
        var clientRect = await containerDiv.MudGetBoundingClientRectAsync();
        var xPos = e.ClientX / clientRect.AbsoluteRight;
        var yPos = 1 - e.ClientY / clientRect.AbsoluteBottom;
        plot.ZoomAt(factor, xPos, yPos);
        skiaEl.Invalidate();
    }
}