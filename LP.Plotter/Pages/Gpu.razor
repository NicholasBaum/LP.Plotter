@page "/gpu"
@using LP.Plotter.Core.Drawing;
@using SkiaSharp
@using SkiaSharp.Views.Blazor
@using static LP.Plotter.Core.Drawing.SignalPlotter;

@inject DataService dataService;

<style>
    .canvas-container {
        line-height: 1;
    }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
        }
</style>

<h1>GPU (WebGL) Canvas</h1>

<p>The canvas below is using WebGL. See the great FPS!</p>

<div class="container" style="border: red 2px solid">
    <div class="row">
        <div class="col border rounded p-2 canvas-container">

            <SKGLView OnPaintSurface="OnPaintSurface" IgnorePixelScaling="true" EnableRenderLoop="true"
            @onmousedown="OnMouseDown"
            @onmousemove="OnMouseMove"
            @onmouseup="OnMouseUp" />

        </div>
    </div>
</div>

@code {

    int tickIndex = 0;
    long tickSum = 0;
    long[] tickList = new long[100];
    long lastTick = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    SignalPlotter drawer;

    protected override async void OnInitialized()
    {
        base.OnInitialized();
        var data = await dataService.LoadTestRun();
        drawer = new SignalPlotter(data);
        OriginalAxis = new Axis() { Min = drawer.XAxis.Min, Max = drawer.XAxis.Max };
    }

    private void OnPaintSurface(SKPaintGLSurfaceEventArgs e)
    {
        var surfaceSize = e.Info.Size;
        using var paint = new SKPaint
            {
                Color = SKColors.White,
                IsAntialias = true,
                StrokeWidth = 5f,
                StrokeCap = SKStrokeCap.Round,
                TextAlign = SKTextAlign.Center,
            };
        using var font = new SKFont
            {
                Size = 24
            };
        var canvas = e.Surface.Canvas;
        this.drawer.Draw(canvas, e.Info);
        var fps = GetCurrentFPS();
        canvas.DrawText($"{fps:0.00}fps", surfaceSize.Width / 2, surfaceSize.Height - 10f, font, paint);
    }

    double GetCurrentFPS()
    {
        var newTick = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        var delta = newTick - lastTick;
        lastTick = newTick;

        tickSum -= tickList[tickIndex];
        tickSum += delta;
        tickList[tickIndex] = delta;

        if (++tickIndex == tickList.Length)
            tickIndex = 0;

        return 1000.0 / ((double)tickSum / tickList.Length);
    }

    private bool isPanning = false;
    private double lastX = 0;
    private Axis OriginalAxis;
    private void OnMouseDown(MouseEventArgs e)
    {
        isPanning = true;
        lastX = (float)e.OffsetX;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (!isPanning) return;
        float offx = 1f * (float)(e.OffsetX - lastX);
        drawer.XAxis.Min += offx;
        drawer.XAxis.Max += offx;
        if (drawer.XAxis.Min >= -0.1)
        {
            drawer.XAxis.Min = OriginalAxis.Min;
            drawer.XAxis.Max = OriginalAxis.Max;
        }

    }
    private void OnMouseUp(MouseEventArgs e)
    {
        isPanning = false;
    }
}